---
title: "EDS 230/ESM 232 Sensitivity Analysis with LHS"
author: "Marie Rivers, Quin Smith, Ian Brunjes"
date: "4/25/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(sensitivity)
library(tidyverse)
library(pse) # parameter space exploration with Latin Hypercubes
library(here)
```

2. Run your model
```{r}
source(here("R", "compute_atm_cond.R"))

atm_cond_q2 <- compute_atm_cond(h = 1000, v = 250)
print(paste0('The calculated atmospheric conductance is ', round(atm_cond_q2$mean_atm_cond, 3), 'cm/s'))
```

3. Sensitivity Analysis

```{r}
# Lets consider the parameters....
factors = c("h", "kd", "k0", "v")

# Decide How many parameter sets to run
nsets=100

# choose distributions for parameters - this would come from
# what you know about the likely range of variation
q = c("qunif", "qnorm", "qnorm", "qnorm")
q.arg = list(list(min=9.5, max=10.5), list(mean=0.7, sd=(.01*0.7)), list(mean=0.1, sd=(.01*0.1)), list(mean=250, sd=30))
```

```{r}
# generate samples from LHS
sens_atm_cond = LHS(NULL,factors,nsets,q,q.arg)
sens_pars = get.data(sens_atm_cond) # table of all the parameters you want to run. Each row is a parameter set that will be run through the model
head(sens_pars)
```

```{r atm_cond sens}
# lets now run our model for all of the parameters generated by LHS
# pmap is useful here - it is a map function that uses the actual names of input parameters

atm_cond_q3 = sens_pars %>% pmap(compute_atm_cond)

# notice that what pmap returns is a list 
head(atm_cond_q3)
```


```{r atm_cond sens}
# turn results in to a dataframe for easy display/analysis
atm_cond_df = atm_cond_q3 %>% map_dfr(`[`,c("max_atm_cond", "min_atm_cond", "mean_atm_cond"))
```


```{r atm_cond sens}
# to take advantage of LHS/pse functions for 
# plotting interesting information we can send results back - 
# results need to be in a matrix
# each column is a different parameter set - we can use transpose (t)
# and as.matrix to get there

# tell is what links output to original LHS object

sens_atm_cond = pse::tell(sens_atm_cond, t(as.matrix(atm_cond_df)), # needs to be a matrix
                        res.names=c("max_atm_cond", "min_atm_cond", "mean_atm_cond")) # transpose because it needs rows and columns switched
```


#  Plotting 

Plot relationship between parameter and output
to understand how uncertainty in parameter impacts the output to determine over what ranges of the parameter uncertainty is most important (biggest effect)


Use a box plot (of output)
to graphically show the impact of uncertainty on output of interest


```{r senplot}
# now we use built in LHS functions to analyze parameter sensitivity
pse::plotscatter(sens_atm_cond, col="blue", cex=5)
```


```{r senplot}
# we can also plot results in interesting ways
# turn sens_almond into a data frame - easier access to R plotting functions

ggplot(atm_cond_df, aes(min_atm_cond, max_atm_cond))+geom_point()+labs(y="Max Atmospheric Conductance (cm/s)", "Min Atmospheric Conductance (cm/s")
```

Always graph the relationship between the parameters and the outcome you are interested in
```{r senplot}
# add uncertainty bounds on our estimates
tmp = atm_cond_df %>% gather(value="value", key="yield")
ggplot(tmp, aes(atm_cond_q3, value, col=atm_cond_q3))+geom_boxplot()+
  labs(y="Atmospheric Conductance (cm/s)")
```


```{r senplot}
# note that you don't see the ranges because of the scale (min yield anomoly much smaller than max) - here's a more informative way to graph
ggplot(tmp, aes(atm_cond_q3, value, col=atm_cond_q3))+
  geom_boxplot()+labs(y="Atmospheric Conductance (cm/s)")+
  facet_wrap(~atm_cond_q3, scales="free" )
```

# Quantifying Sensitivity

# PSE:TELL object  has partial rank correlation coefficients

```{r quantifying}
# prcc's automatically generated and easy to plot
pse::plotprcc(sens_almond)

# PRCC for all 3 output metrix
sens_almond$res.names
sens_almond$prcc

# correlation coefficient
# compare PRCC with first correlation coefficient
# recall
head(yieldsd)
sens_almond$prcc[1]

# we can still use our sens_pars data frame - rows of parameters will be
# match rows in the output from our use of pmap to run the model for all 
# parameters
cor(yieldsd$maxyield, sens_pars$Tmincoeff1, method="spearman")
cor(yieldsd$maxyield, sens_pars$Tmincoeff2, method="spearman")
cor(yieldsd$maxyield, sens_pars$Pcoeff2, method = "spearman")
```





